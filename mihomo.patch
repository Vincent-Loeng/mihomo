diff --git a/component/process/process_freebsd_amd64.go b/component/process/process_freebsd.go
similarity index 90%
rename from component/process/process_freebsd_amd64.go
rename to component/process/process_freebsd.go
index a6d00c8e..a7ca5c76 100644
--- a/component/process/process_freebsd_amd64.go
+++ b/component/process/process_freebsd.go
@@ -177,23 +177,9 @@ func (s *searcher) searchSocketPid(socket uint64) (uint32, error) {
 	return 0, ErrNotFound
 }
 
-func newSearcher(major int) *searcher {
+func newSearcher(major int, machine string) *searcher {
 	var s *searcher
 	switch major {
-	case 11:
-		s = &searcher{
-			headSize:     32,
-			tcpItemSize:  1304,
-			udpItemSize:  632,
-			port:         198,
-			ip:           228,
-			vflag:        116,
-			socket:       88,
-			fileItemSize: 80,
-			data:         56,
-			pid:          8,
-			udpInpOffset: 8,
-		}
 	case 12:
 		fallthrough
 	case 13:
@@ -201,13 +187,21 @@ func newSearcher(major int) *searcher {
 	case 14:
 		fallthrough
 	case 15:
+		var vflag int
+		if machine == "i386" {
+			vflag = 388
+		} else if machine == "amd64" || machine == "arm64" {
+			vflag = 392
+		} else {
+			return nil
+		}
 		s = &searcher{
 			headSize:     64,
 			tcpItemSize:  744,
 			udpItemSize:  400,
 			port:         254,
 			ip:           284,
-			vflag:        392,
+			vflag:        vflag,
 			socket:       16,
 			fileItemSize: 128,
 			data:         56,
@@ -222,6 +216,10 @@ func initSearcher() error {
 	if err != nil {
 		return err
 	}
+	machine, err := syscall.Sysctl("hw.machine")
+	if err != nil {
+		return err
+	}
 
 	dot := strings.Index(osRelease, ".")
 	if dot != -1 {
@@ -231,9 +229,9 @@ func initSearcher() error {
 	if err != nil {
 		return err
 	}
-	defaultSearcher = newSearcher(major)
+	defaultSearcher = newSearcher(major, machine)
 	if defaultSearcher == nil {
-		return fmt.Errorf("unsupported freebsd version %d", major)
+		return fmt.Errorf("unsupported freebsd version %d (%s)", major, machine)
 	}
 	return nil
 }
diff --git a/component/process/process_other.go b/component/process/process_other.go
index eea6e5fd..83b6f085 100644
--- a/component/process/process_other.go
+++ b/component/process/process_other.go
@@ -1,4 +1,4 @@
-//go:build !darwin && !linux && !windows && (!freebsd || !amd64)
+//go:build !darwin && !linux && !windows && !freebsd
 
 package process
 
diff --git a/listener/config/tun.go b/listener/config/tun.go
index 0e262329..235f8736 100644
--- a/listener/config/tun.go
+++ b/listener/config/tun.go
@@ -24,6 +24,7 @@ type Tun struct {
 	Inet6Address           []netip.Prefix `yaml:"inet6-address" json:"inet6-address,omitempty"`
 	IPRoute2TableIndex     int            `yaml:"iproute2-table-index" json:"iproute2-table-index,omitempty"`
 	IPRoute2RuleIndex      int            `yaml:"iproute2-rule-index" json:"iproute2-rule-index,omitempty"`
+	FIBIndex               int            `yaml:"fib-index" json:"fib-index,omitempty"`
 	AutoRedirect           bool           `yaml:"auto-redirect" json:"auto-redirect,omitempty"`
 	AutoRedirectInputMark  uint32         `yaml:"auto-redirect-input-mark" json:"auto-redirect-input-mark,omitempty"`
 	AutoRedirectOutputMark uint32         `yaml:"auto-redirect-output-mark" json:"auto-redirect-output-mark,omitempty"`
@@ -127,6 +128,9 @@ func (t *Tun) Equal(other Tun) bool {
 	if t.IPRoute2RuleIndex != other.IPRoute2RuleIndex {
 		return false
 	}
+	if t.FIBIndex != other.FIBIndex {
+		return false
+	}
 	if t.AutoRedirect != other.AutoRedirect {
 		return false
 	}
diff --git a/listener/sing_tun/server.go b/listener/sing_tun/server.go
index 87f413d4..54d8d7b1 100644
--- a/listener/sing_tun/server.go
+++ b/listener/sing_tun/server.go
@@ -189,6 +189,10 @@ func New(options LC.Tun, tunnel C.Tunnel, additions ...inbound.Addition) (l *Lis
 	if ruleIndex == 0 {
 		ruleIndex = tun.DefaultIPRoute2RuleIndex
 	}
+	fibIndex := options.FIBIndex
+	if fibIndex == 0 {
+		fibIndex = tun.DefaultFIBIndex
+	}
 	inputMark := options.AutoRedirectInputMark
 	if inputMark == 0 {
 		inputMark = tun.DefaultAutoRedirectInputMark
@@ -347,6 +351,7 @@ func New(options LC.Tun, tunnel C.Tunnel, additions ...inbound.Addition) (l *Lis
 		AutoRoute:                options.AutoRoute,
 		IPRoute2TableIndex:       tableIndex,
 		IPRoute2RuleIndex:        ruleIndex,
+		FIBIndex:                 fibIndex,
 		AutoRedirectInputMark:    inputMark,
 		AutoRedirectOutputMark:   outputMark,
 		Inet4LoopbackAddress:     common.Filter(options.LoopbackAddress, netip.Addr.Is4),
